---
title: 手撸 Grid 拖拽布局
date: 2023-11-30 20:07:05
tags:
categories: 记录类
description:
keywords: grid,拖拽布局，vue
---

最近有个需求需要实现自定义首页布局，需要将屏幕按照 6 列 4 行进行等分成多个格子，然后将组件拖拽对应格子进行渲染展示。

![](/images/posts/grid_layout/demo.png)_示例_

<!--more -->

对比一些已有的插件，发现想要实现产品的交互效果，没有现成可用的。本身功能并不是太过复杂，于是决定自己基于 vue 手撸一个简易的 Grid 拖拽布局。

完整源码在此，[在线体验](https://stackblitz.com/edit/vitejs-vite-rkwugn)

## 概况

需要实现 Grid 拖拽布局，主要了解这两个东西就行

-   拖放 API，关于拖放 API 介绍文章有很多 ，可以直接看 MDN 里[拖放 API](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API)介绍，可以说很详细了。
-   Grid 布局， Grid 布局与 Flex 布局很相似，但是 Grid 像是二维布局，Flex 则为一维布局，Grid 布局远比 Flex 布局强大。[MDN 关于网格布局介绍](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout)

需要实现主要包含：

-   组件物料栏拖拽到布局容器
-   布局容器 Grid 布局
-   放置时是否重叠判断
-   拖拽时样式
-   放置后样式
-   容器内二次拖拽

## 拖放操作实现

拖拽中主要使用到的事件如下

-   被拖拽元素事件：

| 事件      | 触发时刻                                   |
| --------- | ------------------------------------------ |
| dragstart | 当用户开始拖拽一个元素或选中的文本时触发。 |
| drag      | 当拖拽元素或选中的文本时触发。             |
| dragend   | 当拖拽操作结束时触发                       |

-   放置容器事件：

| 事件      | 触发时刻                                         |
| --------- | ------------------------------------------------ |
| dragenter | 当拖拽元素或选中的文本到一个可释放目标时触发。   |
| dragleave | 当拖拽元素或选中的文本离开一个可释放目标时触发。 |
| dragover  | 当元素或选中的文本被拖到一个可释放目标上时触发。 |
| drop      | 当元素或选中的文本在可释放目标上被释放时触发。   |

### 可拖拽元素

让一个元素能够拖拽只需要给元素设置 **draggable="true"** 即可拖拽，拖拽事件 API 提供了 **DataTransfer** 对象，可以用于设置拖拽数据信息，但是仅仅只能 **drop** 事件中获取到。因为我们需要在拖拽中就需要获取到拖拽信息，用来显示拖拽时样式，所以需要自己处理这些信息存储起来，以便读取。

需要处理主要是，在拖拽时将 将当前元素信息设置到 **dragStore** 中，结束时清空当前信息。

```html
<script setup lang="ts">
  import { dragStore } from "./drag";

  const props = defineProps<{
    data: DragItem;
    groupName?: string;
  }>();

  const onDragstart = (e) => dragStore.set(props.groupName, { ...props.data });
  const onDragend = () => dragStore.remove(props.groupName);
</script>
<template>
  <div class="drag-item__el" draggable="true" @dragstart="onDragstart" @dragend="onDragend"></div>
</template>
```

封装一个存储方法，通过配置相同 key ，可以在同时存在多个放置区域时候，区分开来。

```ts
class DragStore<T extends DragItemData> {
  moveItem = new Map<string, DragItemData>();

  set(key: string, data: T) {
    this.moveItem.set(key, data);
  }

  remove(key: string) {
    this.moveItem.delete(key);
  }

  get(key: string): undefined | DragItemData {
    return this.moveItem.get(key);
  }
}
```

### 可放置区域

首先是需要告诉浏览器当前区域是可以放置的，只需要在元素监听 **dragenter**、**dragleave**、**dragover** 事件即可，然后通过 **preventDefault** 来阻止浏览器默认行为。可以在这三个事件中处理判断当前位置是否可以放置等等。

示例：

```html
<script setup lang="ts">
  // 进入放置目标
  const onDragenter = (e) => {
    e.preventDefault();
  };

  // 在目标中移动
  const onDragover = (e) => {
    e.preventDefault();
  };

  // 离开目标
  const onDragleave = (e) => {
    e.preventDefault();
  };
</script>
<template>
  <div @dragenter="onDragenter($event)" @dragover="onDragover($event)" @dragleave="onDragleave($event)" @drop="onDrop($event)"></div>
</template>
```

上面的代码已经可以让，元素可以拖拽，当元素拖到可防止区域时候，可以看到鼠标样式会变为可放置样式了。

## Grid 布局

我们是需要进行 Grid 拖拽布局，所以先对上面放置容器进行改造，首先就是需要将容器进行格子划分区域显示。

### 计算 Grid 格子大小

我这里直接使用了 **@vueuse/core** 的 **useElementSize** 的 hooks 去获取容器元素大小变动，也可以自己通过 **ResizeObserver** 去监听元素变动。接着根据设置列数、行数、间隔去计算单个格子大小。

```ts
import { useElementSize } from "@vueuse/core";

/**
 * 容器等分尺寸
 * @param {*} target 容器 HTML
 * @param {*} column 列数
 * @param {*} row 行数
 * @param {*} gap 间隔
 * @returns
 */
export const useBoxSize = (target: Ref<HTMLElement | undefined>, column: number, row: number, gap: number) => {
  const { width, height } = useElementSize(target);
  return computed(() => ({
    width: (width.value - (column - 1) * gap) / column,
    height: (height.value - (row - 1) * gap) / row,
  }));
};
```

### 设置 Grid 样式

根据列数和行数循环生成格子数，**rowCount**、**columnCount**为行数和列数。

```html
<div class="drop-content__drop-container" @dragenter="onDragenter($event)" @dragover="onDragover($event)" @dragleave="onDragleave($event)" @drop="onDrop($event)">
  <template v-for="x in rowCount">
    <div class="bg-column" v-for="y in columnCount" :key="`${x}-${y}`"></div>
  </template>
</div>
```

设置 Grid 样式，下面变量中 **gap** 为格子间隔，**repeat** 是 Grid 用来重复设置相同值的，**grid-template-columns: repeat(2,100px)** 等效于 **grid-template-columns: 100px 100px**。因为我们只需在容器里监听拖拽放置事件，所以我们还需要将
所有的 **bg-column** 事件去掉，设置 **pointer-events: none** 即可。

```scss
.drop-content__drop-container {
  display: grid;
  row-gap: v-bind("gap+'px'");
  column-gap: v-bind("gap+'px'");
  grid-template-columns: repeat(v-bind("columnCount"), v-bind("boxSize.width+'px'"));
  grid-template-rows: repeat(v-bind("rowCount"), v-bind("boxSize.height+'px'"));
  .bg-column {
    background-color: #fff;
    border-radius: 6px;
    pointer-events: none;
  }
}
```

效果如下：
![](/images/posts/grid_layout/grid.png)_Grid 容器样式_

## 放置元素

放置元素时我们需要先计算出元素在 Grid 位置信息等，这样才知道元素应该放置那哪个地方。

### 拖拽位置计算

当元素拖拽进容器中时，我们可以通过 **offsetX**、**offsetY** 两个数据获取当前鼠标距离容器左上角位置距离，我们可以根据这两个值计算出对应的在 Grid 中做坐标。

计算方式：

```ts
// 计算 x 坐标
const getX = (num) => parseInt(num / (boxSizeWidth + gap));
// 计算 y 坐标
const getY = (num) => parseInt(num / (boxSizeHeight + gap));
```

需要注意的是上面计算坐标是 0,0 开始的，而 Grid 是 1,1 开始的。

### 获取拖拽信息

我们在进入容器时，通过上面封装 **dragData** 来获取当前拖拽元素信息，获取它尺寸信息等等。

```ts
// 拖拽中的元素
const current = reactive({
  show: <boolean>false,
  id: <undefined | number>undefined,
  column: <number>0, // 宽
  row: <number>0, // 高
  x: <number>0, // 列
  y: <number>0, // 行
});

// 进入放置目标
const onDragenter = (e) => {
  e.preventDefault();
  const dragData = dragStore.get(props.groupName);
  if (dragData) {
    current.column = dragData.column;
    current.row = dragData.row;
    current.x = getX(e.offsetX);
    current.y = getY(e.offsetY);
    current.show = true;
  }
};

// 在目标中移动
const onDragover = (e) => {
  e.preventDefault();
  const dragData = dragStore.get(props.groupName);
  if (dragData) {
    current.x = getX(e.offsetX);
    current.y = getY(e.offsetY);
  }
};

const onDragleave = (e) => {
  e.preventDefault();
  current.show = false;
  current.id = undefined;
};
```

在 drop 事件中，我们将当前拖拽元素存放起来，list 会存放每一次拖拽进来元素信息。

```ts
const list = ref([]);

// 放置在目标上
const onDrop = async (e) => {
  e.preventDefault();
  current.show = false;
  const item = dragStore.get(props.groupName);

  list.value.push({
    ...item,
    x: current.x,
    y: current.y,
    id: new Date().getTime(),
  });
};
```

### 计算碰撞

在上面还需要计算当前拖拽的位置是否可以放置，需要处理是否包含在容器内，是否与其他已放置元素存在重叠等等。

#### 计算是否在容器内

这个是比较好计算的，只需要当前拖拽位置左上角坐标 >= 容器左上角的坐标，然后右下角的坐标 <= 容器的右下角的坐标，就是在容器内的。

<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 472.22222222222223 448.8888888888887" width="472.22222222222223" height="448.8888888888887">
  <g stroke-opacity="0.9" fill-opacity="0.9" stroke-linecap="round" transform="translate(40 107.77777777777783) rotate(0 200.55555555555551 147.2222222222224)"><path d="M0 0 C82.3 0, 164.61 0, 401.11 0 M0 0 C159.75 0, 319.49 0, 401.11 0 M401.11 0 C401.11 102.5, 401.11 205, 401.11 294.44 M401.11 0 C401.11 83.68, 401.11 167.36, 401.11 294.44 M401.11 294.44 C245.89 294.44, 90.67 294.44, 0 294.44 M401.11 294.44 C310.61 294.44, 220.11 294.44, 0 294.44 M0 294.44 C0 225.76, 0 157.08, 0 0 M0 294.44 C0 188.64, 0 82.83, 0 0" stroke="#f08c00" stroke-width="1" fill="none"></path></g><g stroke-opacity="0.9" fill-opacity="0.9" stroke-linecap="round" transform="translate(95.55555555555554 188.8888888888887) rotate(0 142.2222222222222 63.888888888888914)"><path d="M0 0 C93.16 0, 186.31 0, 284.44 0 M0 0 C82.11 0, 164.21 0, 284.44 0 M284.44 0 C284.44 33.97, 284.44 67.94, 284.44 127.78 M284.44 0 C284.44 48.07, 284.44 96.14, 284.44 127.78 M284.44 127.78 C178.07 127.78, 71.69 127.78, 0 127.78 M284.44 127.78 C222.86 127.78, 161.28 127.78, 0 127.78 M0 127.78 C0 89.06, 0 50.33, 0 0 M0 127.78 C0 99.64, 0 71.5, 0 0" stroke="#1971c2" stroke-width="1" fill="none"></path></g><g stroke-opacity="0.9" fill-opacity="0.9" transform="translate(295.5555555555555 10) rotate(0 0.00005000000000165983 0.00005000000010113581)" stroke="none"><path fill="#f08c00" d="M 1.57,-1.57 Q 1.57,-1.57 1.77,-1.27 1.98,-0.98 2.09,-0.64 2.20,-0.29 2.19,0.05 2.18,0.41 2.05,0.75 1.93,1.09 1.70,1.37 1.48,1.65 1.18,1.84 0.87,2.04 0.52,2.12 0.18,2.21 -0.17,2.18 -0.53,2.15 -0.86,2.01 -1.19,1.87 -1.46,1.63 -1.73,1.39 -1.90,1.07 -2.08,0.76 -2.15,0.41 -2.21,0.05 -2.17,-0.29 -2.12,-0.65 -1.96,-0.97 -1.80,-1.29 -1.54,-1.54 -1.29,-1.80 -0.97,-1.96 -0.65,-2.12 -0.29,-2.17 0.06,-2.21 0.41,-2.15 0.76,-2.08 1.07,-1.90 1.39,-1.73 1.63,-1.46 1.87,-1.19 2.01,-0.86 2.15,-0.53 2.18,-0.17 2.21,0.18 2.12,0.52 2.03,0.87 1.84,1.18 1.65,1.48 1.37,1.70 1.09,1.93 0.75,2.05 0.41,2.18 0.05,2.19 -0.30,2.20 -0.64,2.09 -0.98,1.98 -1.27,1.77 -1.57,1.56 -1.57,1.57 -1.57,1.57 -1.73,1.35 -1.90,1.14 -2.01,0.90 -2.12,0.66 -2.16,0.39 -2.21,0.13 -2.20,-0.13 -2.18,-0.40 -2.10,-0.65 -2.02,-0.91 -1.88,-1.14 -1.74,-1.36 -1.55,-1.55 -1.36,-1.74 -1.14,-1.88 -0.91,-2.02 -0.65,-2.10 -0.40,-2.18 -0.13,-2.20 0.13,-2.21 0.39,-2.16 0.66,-2.12 0.90,-2.01 1.14,-1.90 1.35,-1.73 1.57,-1.57 1.57,-1.57 L 1.57,-1.57 Z"></path></g><g stroke-opacity="0.9" fill-opacity="0.9" transform="translate(25.555555555555543 91.11111111111086) rotate(0 40 56.66666666666674)" stroke="none"><path fill="#e03131" d="M -0.26,1.83 Q -0.26,1.83 -2.43,1.44 -4.59,1.04 -6.52,2.11 -8.44,3.19 -9.26,4.40 -10.09,5.61 -10.80,7.05 -11.52,8.50 -12.19,10.31 -12.87,12.12 -13.17,14.36 -13.48,16.60 -13.64,19.17 -13.80,21.73 -13.81,23.48 -13.82,25.22 -13.88,27.55 -13.95,29.88 -13.96,31.83 -13.96,33.78 -13.62,35.42 -13.29,37.06 -12.60,38.96 -11.91,40.87 -10.98,42.21 -10.05,43.55 -9.00,45.14 -7.95,46.73 -6.64,48.31 -5.33,49.89 -3.78,51.91 -2.24,53.93 -0.07,55.98 2.09,58.04 4.32,60.24 6.56,62.43 9.10,64.97 11.64,67.51 14.58,69.81 17.51,72.12 20.42,74.75 23.32,77.38 27.39,80.70 31.45,84.02 35.41,87.03 39.37,90.03 42.36,92.62 45.36,95.21 47.88,97.24 50.40,99.27 53.04,101.07 55.67,102.87 57.49,104.31 59.30,105.76 60.76,106.98 62.22,108.20 63.22,108.98 64.22,109.75 65.59,111.08 66.96,112.40 68.41,113.54 69.87,114.69 71.44,115.82 73.00,116.95 74.17,117.26 75.34,117.58 76.99,118.46 78.64,119.35 79.74,119.56 80.85,119.77 81.92,119.83 82.99,119.89 84.14,120.30 85.29,120.70 86.47,120.72 87.65,120.74 89.19,120.05 90.73,119.35 92.08,118.63 93.42,117.92 93.22,113.88 93.02,109.84 93.19,105.73 93.36,101.63 92.84,96.16 92.33,90.69 91.83,86.08 91.33,81.48 90.82,77.61 90.32,73.74 89.80,70.51 89.29,67.28 88.47,64.72 87.65,62.17 86.97,59.39 86.29,56.60 85.07,53.27 83.86,49.94 82.08,45.99 80.30,42.03 78.59,38.42 76.88,34.82 75.51,32.00 74.15,29.19 72.62,26.43 71.10,23.66 69.52,21.24 67.93,18.81 66.30,16.51 64.68,14.20 63.06,12.30 61.44,10.40 60.07,8.58 58.71,6.77 56.99,5.50 55.27,4.22 52.92,2.70 50.58,1.17 48.32,-0.10 46.07,-1.37 43.90,-2.20 41.74,-3.04 39.18,-4.05 36.62,-5.06 34.68,-5.45 32.74,-5.83 30.68,-6.01 28.61,-6.18 26.93,-6.50 25.25,-6.83 23.73,-6.91 22.21,-6.99 20.72,-7.32 19.22,-7.66 17.56,-7.80 15.89,-7.94 14.19,-7.99 12.49,-8.04 10.82,-8.04 9.14,-8.05 7.34,-7.91 5.55,-7.77 4.40,-7.68 3.24,-7.58 2.40,-6.50 1.55,-5.41 0.26,-3.97 -1.02,-2.52 0.50,-2.05 2.02,-1.57 2.22,-1.21 2.42,-0.84 2.49,-0.43 2.56,-0.02 2.50,0.38 2.44,0.79 2.25,1.16 2.06,1.53 1.76,1.82 1.46,2.11 1.08,2.28 0.71,2.46 0.29,2.51 -0.11,2.56 -0.51,2.48 -0.92,2.39 -1.28,2.18 -1.64,1.97 -1.91,1.66 -2.18,1.34 -2.34,0.96 -2.50,0.57 -2.52,0.16 -2.55,-0.25 -2.44,-0.65 -2.34,-1.05 -2.11,-1.40 -1.88,-1.74 -1.55,-2.00 -1.22,-2.25 -0.83,-2.39 -0.44,-2.52 -0.02,-2.53 0.38,-2.53 0.78,-2.40 1.17,-2.28 1.51,-2.03 1.84,-1.78 2.08,-1.44 2.31,-1.10 2.43,-0.70 2.54,-0.30 2.53,0.11 2.51,0.52 2.36,0.91 2.21,1.30 1.94,1.62 1.68,1.94 1.32,2.15 0.97,2.37 0.56,2.46 0.16,2.56 -0.24,2.52 -0.66,2.48 -1.04,2.31 -1.41,2.13 -1.72,1.85 -2.02,1.57 -2.02,1.57 -2.02,1.57 -3.81,-1.00 -5.60,-3.58 -4.92,-5.12 -4.24,-6.67 -3.18,-8.05 -2.12,-9.43 -0.71,-10.50 0.70,-11.58 1.82,-11.99 2.94,-12.41 4.26,-12.30 5.58,-12.20 7.39,-12.03 9.21,-11.85 10.92,-11.80 12.64,-11.74 14.43,-11.65 16.21,-11.56 18.23,-11.37 20.24,-11.17 21.40,-10.73 22.56,-10.28 24.28,-10.03 25.99,-9.77 27.42,-9.30 28.84,-8.83 31.06,-8.63 33.29,-8.44 35.44,-7.97 37.58,-7.50 40.14,-6.50 42.69,-5.49 45.02,-4.58 47.36,-3.67 49.69,-2.35 52.01,-1.03 54.44,0.54 56.86,2.12 58.83,3.64 60.80,5.16 62.13,6.92 63.45,8.68 65.15,10.67 66.84,12.67 68.50,15.01 70.16,17.35 71.80,19.86 73.45,22.37 75.01,25.19 76.57,28.01 77.95,30.83 79.33,33.64 81.08,37.27 82.82,40.89 84.66,44.93 86.50,48.97 87.79,52.43 89.08,55.89 89.78,58.56 90.48,61.23 91.42,63.99 92.36,66.75 92.97,70.00 93.58,73.26 94.21,77.15 94.84,81.03 95.51,85.64 96.19,90.25 96.93,95.95 97.68,101.65 97.81,105.78 97.94,109.91 98.07,113.71 98.20,117.52 97.88,119.22 97.55,120.92 96.14,121.96 94.74,123.00 93.74,123.59 92.74,124.17 91.51,124.65 90.28,125.12 88.83,125.41 87.38,125.71 86.25,125.56 85.11,125.41 83.75,124.75 82.39,124.09 81.09,123.85 79.78,123.60 78.32,123.09 76.86,122.59 75.47,121.78 74.08,120.97 72.60,120.31 71.12,119.64 69.47,118.48 67.82,117.31 66.21,116.06 64.61,114.80 63.29,113.49 61.96,112.18 61.14,111.26 60.32,110.34 58.99,109.08 57.66,107.82 55.92,106.44 54.18,105.05 51.46,103.19 48.74,101.33 46.19,99.27 43.63,97.22 40.69,94.68 37.76,92.15 33.76,89.12 29.76,86.10 25.64,82.74 21.51,79.38 18.67,76.82 15.83,74.26 12.77,71.87 9.70,69.47 7.15,66.96 4.60,64.45 2.36,62.30 0.11,60.14 -2.22,57.96 -4.57,55.78 -6.14,53.85 -7.70,51.92 -9.20,50.23 -10.70,48.54 -11.75,46.93 -12.80,45.32 -13.80,43.65 -14.81,41.98 -15.67,39.81 -16.52,37.64 -16.82,35.71 -17.12,33.77 -17.10,31.81 -17.08,29.85 -17.11,27.49 -17.14,25.13 -17.04,23.36 -16.95,21.59 -16.87,18.90 -16.79,16.21 -16.54,13.60 -16.28,10.98 -15.63,8.87 -14.98,6.77 -14.09,5.02 -13.20,3.27 -11.74,1.47 -10.29,-0.32 -8.99,-0.85 -7.70,-1.37 -6.02,-1.84 -4.34,-2.31 -2.04,-2.07 0.26,-1.83 0.47,-1.78 0.69,-1.72 0.89,-1.61 1.08,-1.50 1.25,-1.35 1.41,-1.20 1.53,-1.01 1.66,-0.82 1.73,-0.61 1.81,-0.40 1.83,-0.18 1.85,0.03 1.82,0.26 1.79,0.48 1.71,0.69 1.62,0.89 1.49,1.07 1.36,1.26 1.19,1.40 1.02,1.55 0.82,1.65 0.62,1.75 0.40,1.79 0.18,1.84 -0.03,1.84 -0.26,1.83 -0.26,1.83 L -0.26,1.83 Z"></path></g><g stroke-opacity="0.9" fill-opacity="0.9" transform="translate(414.4444444444444 304.44444444444434) rotate(0 -5.555555555555543 63.888888888888914)" stroke="none"><path fill="#e03131" d="M -0.77,1.94 Q -0.77,1.94 -2.36,1.29 -3.95,0.65 -5.11,0.47 -6.26,0.30 -7.86,-0.14 -9.46,-0.58 -10.61,-0.70 -11.76,-0.81 -13.15,-1.21 -14.55,-1.62 -16.00,-2.11 -17.46,-2.60 -18.82,-2.78 -20.18,-2.95 -22.20,-3.46 -24.21,-3.98 -26.49,-4.24 -28.77,-4.50 -30.11,-4.51 -31.44,-4.52 -33.00,-4.42 -34.56,-4.32 -36.49,-3.52 -38.41,-2.72 -40.05,-1.82 -41.69,-0.92 -43.37,0.34 -45.06,1.61 -46.50,2.61 -47.94,3.62 -49.06,4.60 -50.19,5.59 -51.29,6.64 -52.39,7.69 -53.42,9.44 -54.44,11.20 -55.25,12.93 -56.05,14.66 -56.38,16.50 -56.71,18.34 -56.90,21.04 -57.08,23.73 -57.18,25.85 -57.28,27.98 -57.02,30.38 -56.76,32.78 -56.04,35.33 -55.32,37.89 -54.38,40.58 -53.44,43.28 -52.09,46.65 -50.75,50.02 -48.27,55.26 -45.80,60.50 -43.49,64.62 -41.17,68.74 -38.64,72.03 -36.10,75.32 -33.71,78.69 -31.32,82.06 -28.73,85.37 -26.14,88.69 -23.46,91.67 -20.79,94.65 -17.10,98.47 -13.41,102.29 -9.31,106.14 -5.20,109.98 -1.24,113.19 2.70,116.40 7.54,119.66 12.39,122.92 16.32,124.92 20.24,126.92 23.55,128.75 26.86,130.59 29.71,131.30 32.56,132.02 34.72,132.34 36.89,132.65 38.44,132.69 40.00,132.73 41.10,132.59 42.19,132.46 42.12,130.79 42.04,129.13 42.21,126.86 42.38,124.58 42.82,121.57 43.25,118.56 43.79,115.38 44.32,112.20 44.89,109.25 45.46,106.29 45.70,103.21 45.95,100.13 46.07,96.26 46.18,92.39 46.24,88.51 46.30,84.63 46.33,81.06 46.36,77.49 46.38,73.42 46.40,69.35 46.09,65.44 45.78,61.52 45.02,57.68 44.27,53.83 43.62,50.24 42.98,46.64 42.09,44.27 41.21,41.89 40.79,39.12 40.37,36.34 39.61,34.39 38.84,32.44 38.16,29.89 37.48,27.34 36.88,25.35 36.28,23.36 35.39,22.05 34.49,20.74 33.74,19.91 32.99,19.08 32.25,18.03 31.52,16.97 29.67,15.53 27.82,14.09 26.85,13.50 25.88,12.92 24.84,12.37 23.79,11.82 22.70,11.28 21.61,10.74 20.32,9.74 19.02,8.74 18.01,8.14 17.00,7.54 16.12,6.91 15.23,6.28 13.58,5.73 11.94,5.17 10.92,4.63 9.91,4.09 8.48,3.56 7.05,3.03 5.17,2.61 3.29,2.19 1.82,2.40 0.35,2.61 -0.06,2.60 -0.49,2.59 -0.89,2.45 -1.29,2.30 -1.63,2.03 -1.96,1.76 -2.19,1.40 -2.42,1.04 -2.53,0.63 -2.63,0.21 -2.60,-0.20 -2.56,-0.63 -2.39,-1.02 -2.22,-1.42 -1.94,-1.74 -1.65,-2.05 -1.28,-2.26 -0.91,-2.48 -0.49,-2.56 -0.07,-2.64 0.34,-2.58 0.77,-2.52 1.15,-2.33 1.54,-2.14 1.84,-1.84 2.14,-1.54 2.33,-1.16 2.52,-0.77 2.58,-0.35 2.64,0.06 2.56,0.48 2.48,0.90 2.27,1.28 2.06,1.65 1.74,1.94 1.42,2.22 1.03,2.39 0.64,2.56 0.21,2.60 -0.21,2.63 -0.62,2.53 -1.04,2.42 -1.40,2.19 -1.76,1.96 -2.03,1.63 -2.30,1.30 -2.44,0.90 -2.59,0.50 -2.60,0.07 -2.62,-0.35 -2.49,-0.76 -2.36,-1.17 -2.12,-1.52 -1.87,-1.86 -1.52,-2.11 -1.17,-2.36 -0.76,-2.49 -0.35,-2.61 -0.35,-2.61 -0.35,-2.61 2.84,-2.76 6.04,-2.90 7.16,-2.79 8.27,-2.67 9.27,-2.12 10.27,-1.58 12.00,-0.95 13.72,-0.33 14.60,0.43 15.47,1.20 17.54,2.30 19.61,3.40 20.82,4.19 22.03,4.98 22.95,5.76 23.87,6.54 24.98,7.17 26.10,7.81 27.24,8.52 28.39,9.23 29.57,10.10 30.74,10.97 31.70,11.93 32.65,12.90 33.69,13.95 34.73,15.00 35.24,16.03 35.74,17.07 36.38,18.14 37.03,19.22 37.92,20.90 38.82,22.58 39.42,24.62 40.02,26.66 40.66,29.08 41.31,31.49 42.15,33.72 42.99,35.94 43.35,38.46 43.71,40.99 44.65,43.58 45.60,46.16 46.25,49.74 46.90,53.31 47.69,57.31 48.48,61.31 48.80,65.33 49.13,69.35 49.13,73.43 49.13,77.50 49.13,81.08 49.13,84.65 49.11,88.56 49.08,92.46 49.02,96.40 48.95,100.34 48.75,103.59 48.56,106.84 48.09,109.76 47.62,112.69 47.23,115.84 46.83,118.98 46.58,121.83 46.33,124.68 46.39,127.17 46.44,129.67 46.21,130.92 45.98,132.17 45.23,133.62 44.49,135.07 42.12,135.40 39.74,135.74 38.12,135.49 36.50,135.25 34.20,134.91 31.90,134.57 28.75,133.73 25.61,132.90 22.33,131.08 19.05,129.26 14.98,127.18 10.92,125.11 5.98,121.78 1.04,118.45 -2.97,115.18 -7.00,111.91 -11.16,108.02 -15.31,104.13 -19.03,100.27 -22.76,96.42 -25.49,93.37 -28.23,90.32 -30.86,86.96 -33.48,83.60 -35.85,80.27 -38.22,76.95 -40.86,73.50 -43.51,70.06 -45.88,65.86 -48.24,61.66 -50.77,56.35 -53.29,51.04 -54.67,47.62 -56.06,44.20 -57.05,41.44 -58.04,38.67 -58.85,35.90 -59.65,33.13 -59.98,30.51 -60.31,27.90 -60.28,25.73 -60.26,23.57 -60.15,20.68 -60.05,17.79 -59.70,15.52 -59.35,13.25 -58.56,11.31 -57.76,9.38 -56.52,7.02 -55.29,4.67 -54.07,3.56 -52.86,2.45 -51.54,1.36 -50.22,0.28 -48.93,-0.58 -47.63,-1.44 -45.87,-3.07 -44.12,-4.69 -42.18,-6.10 -40.24,-7.51 -39.18,-7.88 -38.13,-8.25 -36.30,-8.61 -34.47,-8.96 -32.85,-8.78 -31.22,-8.59 -29.86,-8.45 -28.50,-8.31 -25.92,-8.23 -23.35,-8.14 -21.46,-7.84 -19.58,-7.54 -17.78,-7.30 -15.99,-7.05 -13.54,-6.18 -11.10,-5.30 -9.68,-5.05 -8.26,-4.79 -6.82,-4.37 -5.39,-3.94 -3.91,-3.57 -2.42,-3.20 -0.82,-2.57 0.77,-1.94 0.99,-1.82 1.22,-1.70 1.40,-1.53 1.59,-1.35 1.73,-1.14 1.87,-0.93 1.95,-0.70 2.04,-0.46 2.06,-0.21 2.09,0.03 2.05,0.28 2.02,0.53 1.92,0.77 1.83,1.00 1.68,1.21 1.54,1.41 1.34,1.58 1.15,1.74 0.93,1.85 0.70,1.97 0.46,2.02 0.21,2.08 -0.03,2.07 -0.28,2.07 -0.53,2.00 -0.77,1.94 -0.77,1.94 L -0.77,1.94 Z"></path></g></svg>

代码实现：

```ts
/**
 * 判断是否在当前四边形内
 * @param {*} p1 父容器
 * @param {*} p2
 *  对应是 左上角坐标 和 右下角坐标
 *  [0,0,1,1]  => 左上角坐标 0,0  右下角 1,1
 */
export const booleanWithin = (p1: [number, number, number, number], p2: [number, number, number, number]) => {
  return p1[0] <= p2[0] && p1[1] <= p2[1] && p1[2] >= p2[2] && p1[3] >= p2[3];
};
```

#### 计算是否与现有的相交

两个矩形相交情况有很多种，计算比较麻烦，但是我们可以计算他们不相交，然后在取反方式判断是否相交。

不相交情况只有四种，假设有 p1、p2 连个矩形，它们不相交的情况只有四种：

-   p1 在 p2 左边
-   p1 在 p2 右边
-   p1 在 p2 上边
-   p1 在 p2 下边

代码实现：

```ts
/**
 * 判断是两四边形是否相交
 * @param {*} p1 父容器
 * @param {*} p2
 *  对应是 左上角坐标 和 右下角坐标
 *  [0,0,1,1]  => 左上角坐标 0,0  右下角 1,1
 */
export const booleanIntersects = (p1: [number, number, number, number], p2: [number, number, number, number]) => {
  return !(p1[2] <= p2[0] || p2[2] <= p1[0] || p1[3] <= p2[1] || p2[3] <= p1[1]);
};
```

### 在放置前判断

可以通过计算属性去计算，在后面拖拽中处理样式也可以用到。修改 **drop** 中方法，然后在 **drop** 中根据 **isPutDown** 是否有效。

```ts
// 是否可以放置
const isPutDown = computed(() => {
  const currentXy = [current.x, current.y, current.x + current.column, current.y + current.row];
  return (
    booleanWithin([0, 0, columnCount.value, rowCount.value], currentXy) && //
    list.value.every((item) => item.id === current.id || !booleanIntersects([item.x, item.y, item.x + item.column, item.y + item.row], currentXy))
  );
});
```

## 拖拽时样式

上处理了基本拖放数据处理逻辑，为了更好的交互，我们可以在拖拽中显示元素预占位信息，更加直观的显示元素占位大小，类似这样：

![](/images/posts/grid_layout/mask1.png)_可放置示例_

我们可以根据上面 **current** 中信息去计算大小信息，还可以根据 **isPutDown** 去判断当前位置是否可以放置，用来显示不同交互效果。

![](/images/posts/grid_layout/mask2.png)_不可放置示例_

可以直接通过 Grid 的 grid-area 属性，快速计算出放置位置信息，应为我们上面计算的 x 、y 是从 0 开始的，所以这里需要 +1。

```css
grid-area: `${y + 1} / ${x + 1} / ${y + row + 1}/ ${ x + column + 1 }`
```

## 预览容器

在元素放置后，我们还需要根据 list 中数据，生成元素占位样式处理，我们可以拖拽容器上层在放置一个容器，专门用来显示放置后的样式，也是可以直接使用 Grid 布局去处理。

### 预览样式

样式基本上和 **drop-container** 样式抱持一致即可，需要注意的时需要为预览容器设置 **pointer-events: none**，避免遮挡了 **drop-container** 事件监听。

```scss
.drop-content__preview,
.drop-content__drop-container {
  // ...
}
```

每个元素位置信息计算方式，基本和拖拽时样式计算方式一致，直接通过 **grid-area** 去布局就可以了。

```css
grid-area: `${y + 1} / ${x + 1} / ${y + row + 1}/ ${ x + column + 1 }`
```

![](/images/posts/grid_layout/drop.png)_示例_

### 二次拖拽

当元素拖拽进来后，我们还需要对放置的元素支持继续拖拽。因为上面我们将预览事件通过 **pointer-events** 去除了，所以我们需要给每个子元素都加上去。然后给子元素添加 **draggable=true**，然后处理拖拽事件，基本上和上面处理方式一样，在 **dragstart**、**dragend** 处理拖拽元素信息。

然后我们还需在 **onDrop** 进行一番修改，如果是二次拖拽时只需要修改坐标信息，修改原 **onDrop** 处理方式：

```ts
if (item.id) {
  item.x = current.x;
  item.y = current.y;
} else {
  list.value.push({
    ...item,
    x: current.x,
    y: current.y,
    id: new Date().getTime(),
  });
}
```

### 位置偏移优化

当你对元素二次拖拽时，会发现元素会存在偏移问。比如你放置了一个 1x2 元素后，当你从下面拖拽，你会发现拖拽中的占位样式和你拖拽元素位置存在偏差。

效果如下图

![](/images/posts/grid_layout/offset.png)_示例_

出现这情况应为上面我们时根据鼠标位置为左上角进行计算的，所以会存在这种偏差问题，我们可在拖拽前计算出偏移量来校正位置。

我们可以在二次拖拽时，获取到鼠标在当前元素内位置信息

```ts
const onDragstart = (e) => {
  const data = props.data;
  data.offsetX = e.offsetX;
  data.offsetY = e.offsetY;
  dragStore.set(props.groupName, data);
};
```

在 **drop-container** 内计算 x、y 值时候减去偏移量，对 **onDragenter**、**onDragover** 进行如下调整修改

```ts
current.x = getX(e.offsetX) - getX(dragData?.offsetX ?? 0);
current.y = getY(e.offsetY) - getY(dragData?.offsetY ?? 0);
```

### 拖拽元素优化

因为上面我们将预览元素添加了 **pointer-events: all**，所以在我们拖拽到现有元素上时，会挡住 **drop-container** 事件的触发，在二次拖拽时，比如将一个 2x2 元素我们需要往下移动一格时，会发现也会被自己挡住。

-   预览元素遮挡问题，可以在拖拽时将其他元素都设置为 **none**，二次拖拽时要做自己设置为 **all** 否则会无法拖拽

```html
:style="{ pointerEvents: current.show && item.id !== current.id ? 'none' : 'all' }"`
```

-   二次拖拽时自己位置遮挡问题
    我们可以在拖拽时增加标识，将自己通过 **transform** 移除到多拽容器外去

```ts
moveing.value
  ? {
      opacity: 0,
      transform: `translate(-999999999px, -9999999999px)`,
    }
  : {};
```

### 拖拽调整大小

调整大小和调整位置计算类似，只不过一个是计算坐标一个计算行列。

首先是能让元素可以进行拖拽，很多拖拽调整大小的都是在元素里添加几个拖拽节点元素，然后在监听拖拽节点鼠标事件去计算大小位置等。但是我这里需求比较简单，就不需要做的那么复杂，直接通过 css 让元素可以支持调整大小。

```css
.preview-item {
  overflow: auto;
  resize: both;
}
```

添加样式后，可以看到元素可调整样式

![resize](/images/posts/grid_layout/resize.png)

监听元素大小调整方式有两种

-   通 **ResizeObserver API** 监听，但是这个 API 还会监听到其他因数引起变动，比如窗口大小变动，导致元素变动等等。
-   使用 **mousedown**、**mousemove**、**mouseup** 组合使用，监听鼠标事件，但是这个会存在与拖放事件同时触发问题。

两种方式都可以实现，但是都有需要解决问题，我这里选择了第二种方式实现。

大概实现就是在 PreviewItem 中监听 **mousedown** 事件，在 **mousemove** 中获取元素宽度大小实时计算宽度大小就可以。需要注意的是在 **mouseup** 中要重置 size 信息避免改变原有元素大小。

```ts
const onMousedown = (e) => {
  dragStore.set(props.groupName, props.data);
  emits("resize-start");
  resizeing.value = true;

  e.target.onmousemove = function (event) {
    emits("resizeing", {
      width: event.target.offsetWidth,
      height: event.target.offsetHeight,
    });
  };

  e.target.onmouseup = function (event) {
    unset(event.target);
    emits("resize-end");
    event.target.style.width = "100%";
    event.target.style.height = "100%";
    dragStore.remove(props.groupName);
  };
};

const unset = (target) => {
  resizeing.value = false;
  target.onmousemove = null;
  target.onmouseup = null;
};
```

在 DropContent 通过上面抛出信息，计算大小改变，然后设置拖拽时样式动态查看当前占位大小。

```ts
// 调整大小开始
const onResizeStart = () => {
  const dragData = dragStore.get(props.groupName);
  if (dragData) {
    current.column = dragData.column;
    current.row = dragData.row;
    current.x = dragData.x;
    current.y = dragData.y;
    current.id = dragData.id;
    current.show = true;
  }
};

// 调正大小时
const onResizeing = (e) => {
  const dragData = dragStore.get(props.groupName);
  current.column = getColumn(e.width);
  current.row = getRow(e.height);
};

// 调整大小结束
const onResizeEnd = async () => {
  current.show = false;
  const dragData = dragStore.get(props.groupName);
  if (
    isPutDown.value &&
    (await props.beforeDrop(
      {
        ...dragData,
        column: current.column,
        row: current.row,
      },
      list.value
    ))
  ) {
    dragData.column = current.column;
    dragData.row = current.row;
  }
};
```

实现效果：

![resize_demo](/images/posts/grid_layout/resize_demo.png)

## 结语

到目前为止基本上的 Grid 拖拽布局大致实现了，已经满足基本业务需求了，当然有需要朋友还可以在上面增加碰撞后自动调整位置等等。

完整源码在此，[在线体验](https://stackblitz.com/edit/vitejs-vite-rkwugn)
